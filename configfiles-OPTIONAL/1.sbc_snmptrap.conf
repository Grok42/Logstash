### Hello Justin. Long time. Was checking into some old contacts on LinkedIn. 
### 24/7 Production @ 40-60/wk. +24/7 365 on call IT Mangager for 2 years was starting to be a drag.
### Looking for slower pace. Applying DevOps, one interview at Elastic on Monday
### Anyway, Created some ELK Projects at my last company. None Security related (umm..), but some may be of use to you
### I'll drop the Redacted versions on here if interested.
### Some is device monitoring, Session Border Controller with SNMPTRAPs, Itegrated Media Gateway log file monitoring
### Remote Agent Management (USA & Overseas) via PingPlotter (more accuracy) using Winlogbeat to track RDP session events.
### Integrated Alerting for devices with PagerDuty. Plus a Logstash config & cronjob to bypass Event Inteligence ($$$) @ $10/mo.
### They got disused due to lack of time, but some Telco 3rd party application logfile monitoring.
### Was beginning on a form based input for our operators that would pass to ELK for Agent issue trouble-ticket/shooting.
### Used Heartbeat for awhile with 100+ agents & 50-60 devices, but other IT thought interface not intuitive. Couldn't interest.
### Sonus SBC MIB translation yamls.
### Translate yamls for company specific, customer name & ip info to use for metadata. (not really any use here).
### Unsure if this project includes ONLY Security Onion or Cyber. If other Logstash configs desired I could post some.
### For now will just post this Sonus SBC SNMPTRAP/PagerDuty related stuff.
### Looking for some side work to learn more on ELK. Paid I'd accept if anyone offered piece-meal. 
### Want to do more work for the Open Source community though. Thought this may be a good place to start.
### SBC SNMPTRAP Logstash .conf #1 below (Needs cleanup. We patch holes at my job, not do things pretty. Lol.)

input {
  snmptrap {
    host => "0.0.0.0"
    port => 1026
    community => [ "admin", "operator", "guest" ]
    yamlmibdir => "/usr/share/logstash/vendor/bundle/jruby/2.3.0/gems/snmp-1.3.1/data/ruby/snmp/mibs/"
    id => "elk2_snmptrap"
    add_field => { "source_input" => "snmptrap" }
  }
}
filter {
  if "snmptrap" in [source_input] {
    if "{redacted ip}" in [host] {
      mutate {
        add_field => { source_loc => "stl_sbc" }
        update => { "source_input" => "sbc_snmptrap" }
      }
    }
    if "sbc_snmptrap" in [source_input] {
      mutate {
        rename => {
          "DISMAN-EXPRESSION-MIB::sysUpTimeInstance" => "sbcUptime"
          "SNMPv2-MIB::snmpTrapOID.0" => "trap_OID"
          "SONUS-COMMON-TRAP-MIB::sonusAlarmDescription.0" => "AlarmDescription"
          "SONUS-COMMON-TRAP-MIB::sonusAlarmLevel.0" => "AlarmLevel"
          "SONUS-COMMON-TRAP-MIB::sonusAlarmNodeID.0" => "AlarmNodeID"
          "SONUS-COMMON-TRAP-MIB::sonusAlarmSequenceId.0" => "AlarmSequenceID"
          "SONUS-COMMON-TRAP-MIB::sonusAlarmTime.0" => "AlarmTime"
          "SONUS-SBX-TRAP-MIB::sonusSipArsStatEndpointIpAddress.0" => "PingPeerIpAddress"
          "SONUS-SBX-TRAP-MIB::sonusSipArsStatEndpointIpPortNum.0" => "PingPeerPortNum"
          "SONUS-SBX-TRAP-MIB::sonusSipArsStatEndpointOwnerId.0" => "PingPeerOwnerID"
          "SONUS-SBX-TRAP-MIB::sonusSipArsStatSigPortNum.0" => "SigPortNum"
          "SONUS-SBX-TRAP-MIB::sonusSipArsStatSigZoneId.0" => "SigZoneID"
          "SONUS-SBX-TRAP-MIB::sonusPingPeerIpAddress.0" => "PingPeerIpAddress"
          "SONUS-SBX-TRAP-MIB::sonusPingPeerPortNum.0" => "PingPeerPortNum"
          "SONUS-SBX-TRAP-MIB::sonusPingPeerZoneId.0" => "PingPeerZoneId"
          "HORNET-BASE-TRAPS-MIB::sonusSystemSecurityNotificationDetails.0" => "NotificationDetails"
          "HORNET-BASE-TRAPS-MIB::sonusCpCdrServerIpAddress.0" => "CdrServerIpAddress"
          "HORNET-BASE-TRAPS-MIB::sonusCpCdrServerType.0" => "CpCdrServerType"
          "HORNET-BASE-TRAPS-MIB::sonusCpEventLogType.0" => "CpEventLogType"
          "SONUS-GEN2-EVENT-LOG-MIB::sonusEventLogTypeStatusCurrentFile.0" => "StatusCurrentFile"
        }
        add_field => {
          "alert_type" => "non_noc"
          "email" => "routine"
        }
      }
      translate {
        dictionary => {
          "SONUS-SBX-TRAP-MIB::sonusSbxPathCheckPingStateDownNotification"   => "DOWN"
          "SONUS-SBX-TRAP-MIB::sonusSbxPathCheckPingStateUpNotification"     => "UP"
          "SONUS-SBX-TRAP-MIB::sonusSbxArsEndPointBlacklistedNotification"   => "BLACKLISTED"
          "SONUS-SBX-TRAP-MIB::sonusSbxArsEndPointRecoveredNotification"     => "RECOVERED"
        }
        exact => true
        field => "trap_OID"
        destination => "noc_type"
        fallback => "no-match"
      }
      if "DOWN" in [noc_type] or "UP" in [noc_type] or "BLACKLISTED" in [noc_type] or "RECOVERED" in [noc_type] {
        mutate {
          add_field => { "sbc_trap_type" => "sbc_pingpeer" }
          update => {
            "alert_type" => "noc"
            "email" => "noc"
          }
        }
      }
      if "DOWN" in [noc_type] {
        mutate {
          add_field => {
            "pagerduty" => "sbc_noc"
            "pd_event" => "trigger"
          }
        }
      }
      if "UP" in [noc_type] {
        mutate {
          add_field => {
            "pagerduty" => "sbc_noc"
            "pd_event" => "resolve"
          }
        }
      }
      if "sbc_pingpeer" in [sbc_trap_type] {
        translate {
          dictionary_path => "/usr/share/logstash/sbc_translate/sbc_ipPeers_company.yaml"
          exact => true
          field => "PingPeerIpAddress"
          destination => "ip_company"
          fallback => "no-match"
        }
        translate {
          dictionary_path => "/usr/share/logstash/sbc_translate/sbc_ipPeers_circuit.yaml"
          exact => true
          field => "PingPeerIpAddress"
          destination => "ip_circuit"
          fallback => "no-match"
        }
      }
    }
  }
}
output {
  if "sbc_snmptrap" in [source_input] {
    elasticsearch {
      hosts => [ "localhost:9200" ]
      manage_template => false
      index => "logstash_%{source_loc}_%{source_input}-%{+YYYY.MM.dd}"
      user => elastic
      password => changeme
    }
    if "noc" in [email] {
      email {
        to => "REDACTED"
        via => "smtp"
        address => "smtp.sendgrid.net"
#alt         address => "smtp.gmail.com"
        use_tls => true
        port => 587
        username => "apikey"
        password => "API KEY REDACTED"
        username => "REDACTED@gmail.com"
        password => "REDACTED"
        subject => "SBC-%{noc_type} || %{PingPeerIpAddress} || %{ip_company} || %{ip_circuit}"
        subject => "SBC-%{noc_type} || %{PingPeerIpAddress} || %{ip_company} || %{ip_circuit}"
        body => "SBC SNMP NOC ALERT\n--- Timestamp: %{@timestamp}\n\nPingPeerIP: %{PingPeerIpAddress}\nTrapType: %{noc_type}\nAlarm Description: %{AlarmDescription}\nPingPeerCompany: %{ip_company}\nPingPeerCircuit: %{ip_circuit}\n\nKibana: [ https:\\REDACTED_KIBANA:5601 ]\n\nRaw SNMP Message: %{message}"
      }
    }
    if "routine" in [email] {
      email {
        to => "REDACTED"
        via => "smtp"
        address => "smtp.sendgrid.net"
#alt     address => "smtp.gmail.com"
        use_tls => true
        port => 587
        username => "apikey"
        password => "API KEY REDACTED"
        username => "REDACTED@gmail.com"
        password => "REDACTED"
        subject => "SBC || %{AlarmDescription}"
        body => "SBC SNMP ALERT\n--- Timestamp: %{@timestamp}\n\nAlarmDescription: %{AlarmDescription}\n\nKibana: [ https:\\REDACTED_KIBANA:5601 ]\nKibana Tags: %{tags}\n\nRaw SNMP Message: %{message}"
      }
    }
    if "DOWN" in [noc_type] {

###Old PagerDuty (bypass was needed to keep to $10/mth. tier.
#      pagerduty {
#        id => "sbc_pd_trigger"
#       description => "SBC SNMPTRAP NOC ALERT"
#       details => {
#          "timestamp" => "%{@timestamp}"
#          "noc_alert" => "%{AlarmDescription}"
#        }
#        event_type => "trigger"
#       incident_key => "logstash_sbc_traps/%{host}/%{source_input}"
#       pdurl => "REDACTED"
#       service_key => "REDACTED_PD"
#      }


### New Redirect to file to bypass PagerDuty Event Inteligence we couldn't afford.
      file {
        path => "/var/log/logstash/noc-sbc_trap/peer_down/noc-%{ip_circuit}_%{ip_company}_%{PingPeerIpAddress}.log"
        codec => line { format => "NOC::DOWN::SBC-PEER::%{ip_circuit}::%{ip_company}::%{PingPeerIpAddress}"}
        write_behavior => "overwrite"
      }
    }
    if "UP" in [noc_type] {

###Old PagerDuty (bypass was needed to keep to $10/mth. tier.
#      pagerduty {
#        id => "sbc_pd_resolve"
#        description => "SBC SNMPTRAP NOC ALERT"
#        details => {
#          "timestamp" => "%{@timestamp}"
#          "noc_alert" => "%{AlarmDescription}"
#        }
#        event_type => "resolve"
#        incident_key => "logstash_sbc_traps/%{host}/%{source_input}"
#        pdurl => "REDACTED"
#       service_key => "REDACTED_PD"
#      }
      
### New Redirect to file to bypass PagerDuty Event Inteligence we couldn't afford.	  
	  file {
        path => "/var/log/logstash/noc-sbc_trap/peer_down/noc-%{ip_circuit}_%{ip_company}_%{PingPeerIpAddress}.log"
        codec => line { format => "NOC::UP::SBC-PEER::%{ip_circuit}::%{ip_company}::%{PingPeerIpAddress}"}
        write_behavior => "overwrite"
      }
    }
  }
}


